<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://michalkowol.github.io/tags/development/index.xml</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://michalkowol.github.io/tags/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Simple HTTP servers in Java</title>
      <link>https://michalkowol.github.io/posts/2016-12-01-java-simple-http-servers/</link>
      <pubDate>Thu, 01 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/2016-12-01-java-simple-http-servers/</guid>
      <description>

&lt;h2 id=&#34;java-build-in&#34;&gt;Java build-in&lt;/h2&gt;

&lt;p&gt;Since Java SE 6, there&amp;rsquo;s a builtin HTTP server in &lt;del&gt;Sun&lt;/del&gt; Oracle JRE. The com.sun.net.httpserver package summary outlines the involved classes and contains examples.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;
import lombok.SneakyThrows;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;

public class BootSunHttp {

    public static void main(String[] args) {
        new BootSunHttp().bootServer();
    }

    @SneakyThrows
    private void bootServer() {
        HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0);
        server.createContext(&amp;quot;/test&amp;quot;, new SimpleHandler());
        server.setExecutor(null); // creates a default executor
        server.start();
    }

    private static class SimpleHandler implements HttpHandler {

        @Override
        public void handle(HttpExchange t) throws IOException {
            String response = &amp;quot;This is the response&amp;quot;;
            t.sendResponseHeaders(200, response.length());
            OutputStream os = t.getResponseBody();
            os.write(response.getBytes());
            os.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Noted should be that the response.length() part in their example is bad, it should have been response.getBytes().length. Even then, the getBytes() method must explicitly specify the charset which you then specify in the response header. Alas, albeit misguiding to starters, it&amp;rsquo;s after all just a basic kickoff example.&lt;/p&gt;

&lt;p&gt;As to using &lt;code&gt;com.sun.*&lt;/code&gt; classes, do note that this is, in contrary to what some developers think, absolutely not forbidden by the well known FAQ &lt;a href=&#34;http://www.oracle.com/technetwork/java/faq-sun-packages-142232.html&#34;&gt;Why Developers Should Not Write Programs That Call &amp;lsquo;sun&amp;rsquo; Packages&lt;/a&gt;. That FAQ concerns the sun.* package (such as sun.misc.BASE64Encoder) for internal usage by the Oracle JRE (which would thus kill your application when you run it on a different JRE), not the com.sun.* package. Sun/Oracle also just develop software on top of the Java SE API themselves like as every other company such as Apache and so on. Using com.sun.* classes is only discouraged (but not forbidden) when it concerns an implementation of a certain Java API, such as GlassFish (Java EE impl), Mojarra (JSF impl), Jersey (JAX-RS impl), etc.&lt;/p&gt;

&lt;h2 id=&#34;spark&#34;&gt;Spark&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import spark.Request;
import spark.Response;
import spark.Route;

import static spark.Spark.get;
import static spark.Spark.port;

public class BootSparkHttp {

    private final BarHandler barHandler = new BarHandler();

    public static void main(String[] args) {
        new BootSparkHttp().run();
    }

    private void run() {
        port(8080);
        get(&amp;quot;/hello&amp;quot;, (request, response) -&amp;gt; &amp;quot;Hello World!&amp;quot;);
        get(&amp;quot;/foo/:id&amp;quot;, this::foo);
        get(&amp;quot;/bar/:id&amp;quot;, barHandler);
    }

    private String foo(Request request, Response response) throws Exception {
        String id = request.params(&amp;quot;:id&amp;quot;);
        response.type(&amp;quot;application/json&amp;quot;);
        return &amp;quot;{\&amp;quot;foo\&amp;quot;: \&amp;quot;&amp;quot; + id + &amp;quot;\&amp;quot;}&amp;quot;;
    }

    private static class BarHandler implements Route {
        @Override
        public String handle(Request request, Response response) throws Exception {
            String id = request.params(&amp;quot;:id&amp;quot;);
            return &amp;quot;bar=&amp;quot; + id;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/3732109/simple-http-server-in-java-using-only-java-se-api&#34;&gt;simple HTTP server in Java using only Java SE API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sparkjava.com/&#34;&gt;Spark Framework - A tiny Java web framework&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Akka (notes, part 1)</title>
      <link>https://michalkowol.github.io/posts/2014-12-01-akka-notes-part-1/</link>
      <pubDate>Mon, 01 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/2014-12-01-akka-notes-part-1/</guid>
      <description>

&lt;h3 id=&#34;akka-traits&#34;&gt;Akka traits&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://michalkowol.github.io/img/akka-notes/reactive-traits.svg&#34; alt=&#34;akka traits&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Akka has 4 main traits. Those are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Responsive - the system responds very fast.&lt;/li&gt;
&lt;li&gt;Resilient - the system stays responsive in the face of failure.&lt;/li&gt;
&lt;li&gt;Elastic - the system stays responsive under varying workload. You can easily add/remove nodes (machines) to/from system.&lt;/li&gt;
&lt;li&gt;Message Driven - object talks through messages. Objects are loosely coupled. There is a big diffrence between event and message - every message has recipient address, but events don&amp;rsquo;t have to have it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please see &lt;a href=&#34;http://www.reactivemanifesto.org/&#34;&gt;Reactive Manifesto&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h3 id=&#34;concurrency-vs-parallelism&#34;&gt;Concurrency vs parallelism&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Definition 1

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Concurrency&lt;/strong&gt; is when two tasks can start, run, and complete in overlapping time periods. It doesn&amp;rsquo;t necessarily mean they&amp;rsquo;ll ever both be running at the same instant. Eg. multitasking on a single-core machine.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parallelism&lt;/strong&gt; is when tasks literally run at the same time, eg. on a multicore processor.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Definition 2

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Concurrency&lt;/strong&gt; A condition that exists when at least two threads are making progress. A more generalized form of parallelism that can include time-slicing as a form of virtual parallelism.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parallelism&lt;/strong&gt; A condition that arises when at least two threads are executing simultaneously.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ref: &lt;a href=&#34;http://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&#34;&gt;stackoverflow.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Example&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Concurrency - two queues, one coffee machine&lt;/li&gt;
&lt;li&gt;Parallelism - two queues, two coffee machines&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://michalkowol.github.io/img/akka-notes/con_and_par.jpg&#34; alt=&#34;Concurrency vs Parallelism&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Source: &lt;a href=&#34;http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html&#34;&gt;joearms.github.io&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;actor-actorref&#34;&gt;Actor, ActorRef&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://michalkowol.github.io/img/akka-notes/actor-ref.png&#34; alt=&#34;Actor with Mailbox&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each actor has dispatcher and mailbox.&lt;/li&gt;
&lt;li&gt;If we send message to actor, it will add message to its mailbox and it will return &lt;strong&gt;immediately&lt;/strong&gt; - this is not blocking operation.&lt;/li&gt;
&lt;li&gt;If we create actor, &lt;code&gt;actorOf&lt;/code&gt; will return &lt;strong&gt;immediately&lt;/strong&gt; &lt;code&gt;ActorRef&lt;/code&gt;. It does not wait to create an instance. If we send messages to actor that is &amp;ldquo;not started&amp;rdquo;, messages will be added to mailbox and will be processed when actor is inicialized - we will not lose any message.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dispatcher&lt;/code&gt; assigns (schedules) thread to process the message.&lt;/li&gt;
&lt;li&gt;Many actors have the same dispatcher - it is some kind of thread pool.&lt;/li&gt;
&lt;li&gt;One message is passed to the actor&lt;/li&gt;
&lt;li&gt;Only &lt;strong&gt;one&lt;/strong&gt; thread can be in &lt;strong&gt;receive&lt;/strong&gt; block (&amp;ldquo;single-threaded illusion&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;Actors could have mutable state (but rember not to share mutable state!).&lt;/li&gt;
&lt;li&gt;Messages must be immutable.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;how-to-handle-unhandled-messages&#34;&gt;How to handle &amp;ldquo;unhandled&amp;rdquo; messages&lt;/h3&gt;

&lt;p&gt;If in receive block we do not handle some message, this message will be dropped (and maybe logged). We can use &lt;code&gt;unhandled&lt;/code&gt; method to do something with messages not handled in receive block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;override def unhandled(message: Any): Unit = ???
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;top-level-actor&#34;&gt;Top-Level Actor&lt;/h3&gt;

&lt;p&gt;If you create top-level actors, use factory methods - it will simplify testing. Always give name to your top-level actors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val topLevelActor = createTopLevelActor()
def createTopLevelActor(): ActorRef = system.actorOf(TopLevel.props, &amp;quot;top-level&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;message-protocol&#34;&gt;Message protocol&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Defince your message protocol in the companion object of the actor.&lt;/li&gt;
&lt;li&gt;If you use message protocol from other actor, use actor name as prefix to this message - this will make code more readable.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object FooActor {
  case object FooMessage
}
class FooActor extends Actor {
  import FooActor._
  override def receive: Receive = {
    case FooMessage =&amp;gt; ???
    case BarActor.BarMessage =&amp;gt; ???
  }
}

object BarActor {
  case object BarMessage
}
class BarActor extends Actor {
  import BarActor._
  override def receive: Receive = {
    case FooActor.FooMessage =&amp;gt; ???
    case BarMessage =&amp;gt; ???
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;actor-dsl&#34;&gt;Actor DSL&lt;/h3&gt;

&lt;p&gt;To create anonymous actoes we can use &lt;a href=&#34;http://doc.akka.io/docs/akka/2.3.0-RC1/scala/actordsl.html&#34;&gt;Actor DSL&lt;/a&gt;. Here, &lt;code&gt;actor&lt;/code&gt; takes the role of either &lt;code&gt;system.actorOf&lt;/code&gt; or &lt;code&gt;context.actorOf&lt;/code&gt;. It takes an implicit &lt;code&gt;ActorRefFactory&lt;/code&gt; and creates the new &lt;code&gt;Actor&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import akka.actor.ActorDSL._
 
val a = actor(new Act {
  become {
    case &amp;quot;hello&amp;quot; =&amp;gt; sender() ! &amp;quot;hi&amp;quot;
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;best-practices&#34;&gt;Best practices&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Always create &lt;code&gt;Props&lt;/code&gt; factory - the best place for that is in companion object (see: &lt;a href=&#34;http://doc.akka.io/docs/akka/snapshot/scala/actors.html&#34;&gt;Actors — Akka Documentation&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Put Companion Object before you class.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;sender()&lt;/code&gt; &lt;strong&gt;with&lt;/strong&gt; parentheses. It is function, not val and you have to rember about it. It can be very tricky when &lt;code&gt;sender()&lt;/code&gt; will be execute in other thread - in example in &lt;code&gt;Future&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class WrongWayActor extends Actor {
  override def receive: Receive = {
    case _ =&amp;gt; Future {
      val result = doSomeHeavyComputation
      sender() ! result // if you reacive other message in meantime, it will send the response to WRONG actor
    }
  }
}
 
class GoodWayActor extends Actor {
  override def receive: Receive = {
    case _ =&amp;gt;
      val originalSender = sender()
      Future {
        val result = doSomeHeavyComputation
        originalSender ! result  // it closes clouser over - it will send response to right actor
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scala (notes)</title>
      <link>https://michalkowol.github.io/posts/2014-11-28-scala-notes/</link>
      <pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/2014-11-28-scala-notes/</guid>
      <description>

&lt;h3 id=&#34;functions-without-parameters&#34;&gt;Functions without parameters&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def foo: String = ???
def bar(): String = ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first one is better, bacause you can easly replace it with &lt;code&gt;val&lt;/code&gt;. In fact, otheres developers shouldn&amp;rsquo;t know if you use &lt;code&gt;val&lt;/code&gt; or &lt;code&gt;def&lt;/code&gt;. It should be transparent (you shouldn&amp;rsquo;t use parentheses).&lt;/p&gt;

&lt;h3 id=&#34;default-parameters&#34;&gt;Default parameters&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Welcome(message: String = &amp;quot;default&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;public-api&#34;&gt;Public API&lt;/h3&gt;

&lt;p&gt;If we define public API, all methods and parameters should have explicite type.&lt;/p&gt;

&lt;h3 id=&#34;operators&#34;&gt;Operators&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1 + 3 == (1).+(3)
!true == true.unary_!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To be consisten:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;all operators like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, etc. should be used with infix notation,&lt;/li&gt;
&lt;li&gt;in other cases we &lt;strong&gt;should&lt;/strong&gt; use dot notation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;named-parameters&#34;&gt;Named parameters&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;case class User(name: String, lastname: String)
User(name = &amp;quot;Michal&amp;quot;, lastname = &amp;quot;Kowol&amp;quot;) == User(lastname = &amp;quot;Kowol&amp;quot;, name = &amp;quot;Michal&amp;quot;) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we have a lot of parameters (especially with the same type - integers and strings), we should used named parameters. It makes code more readable and more expressible.&lt;/p&gt;

&lt;h3 id=&#34;imports-in-code-s-block-are-ok&#34;&gt;Imports in code&amp;rsquo;s block are ok&lt;/h3&gt;

&lt;p&gt;If you need specific import only in one function, import it in function body.&lt;/p&gt;

&lt;h3 id=&#34;private-access-modifiers-in-scala&#34;&gt;Private access modifiers in Scala&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package com.michal

class A {
  private def defaultPrivate = ???
  private [this] def superPrivate(other: A) {
    //other.superPrivate(this) // error
    other.defaultPrivate
    superPrivate(other)
  }
  private [michal] def publicInPackage = ???
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package com.michal

class B {
  def test(a: A) = {
    a.publicInPackage
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package com

import com.michal.A

class C {
  def test(a: A) {
    // a.publicInPackage
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;private [this]&lt;/code&gt; is very restrict. It can be be called only in &amp;ldquo;this&amp;rdquo;. You can use package access modifier (it could be good for tests).&lt;/p&gt;

&lt;h3 id=&#34;should-i-extend-app-or-should-i-use-main-args-array-string&#34;&gt;Should I extend &lt;code&gt;App&lt;/code&gt; or should I use &lt;code&gt;main(args: Array[String])&lt;/code&gt;?&lt;/h3&gt;

&lt;p&gt;Extending &lt;code&gt;App&lt;/code&gt; is code for prototyping. In production you should use &lt;code&gt;main&lt;/code&gt;. Why?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Whole object body is treatead as main,&lt;/li&gt;
&lt;li&gt;you don&amp;rsquo;t hava access to args,&lt;/li&gt;
&lt;li&gt;&lt;blockquote&gt;It should be noted that this trait is implemented using the DelayedInit functionality, which means that fields of the object will not have been initialized before the main method has been executed.&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;copy-method-in-case-classes&#34;&gt;&lt;code&gt;copy&lt;/code&gt; method in case classes&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class User(name: String, age: Int)
User(name = &amp;quot;Bob&amp;quot;, age = 10).copy(age = 40) // User(Bob, 40)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;list-vs-vector&#34;&gt;List vs Vector&lt;/h3&gt;

&lt;h4 id=&#34;list&#34;&gt;List&lt;/h4&gt;

&lt;p&gt;List has only pointer to first element - it adds very fast to head of list. To add element to end of list it has to iterate throught all elements (&lt;code&gt;O(n)&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;vector&#34;&gt;Vector&lt;/h4&gt;

&lt;p&gt;All operations are constant in time (even putting element in the middile of collection).&lt;/p&gt;

&lt;h5 id=&#34;performance-characteristics&#34;&gt;Performance characteristics&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://michalkowol.github.io/img/scala-notes/performance.png&#34; alt=&#34;performance characteristics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;Performance characteristics&#34;&gt;Performance characteristics&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;seq-is-mutable&#34;&gt;&lt;code&gt;Seq&lt;/code&gt; is mutable!&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val s = Array(1 ,2, 3) // s: Array[Int] = Array(1, 2, 3)
def testCase(s: Seq[Int]) = s // testCase: TestCase[](val s: Seq[Int]) =&amp;gt; Seq[Int]
testCase(s) // res0: Seq[Int] = WrappedArray(1, 2, 3)
s(0) = 7 // res1: Unit = ()
testCase(s) // res2: Seq[Int] = WrappedArray(7, 2, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is at least one mutable subtype of &lt;code&gt;Seq&lt;/code&gt;: &lt;code&gt;WrappedArray&lt;/code&gt;. To be sure sequence is immutable use &lt;code&gt;scala.collection.immutable.Seq&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;future&#34;&gt;Future&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scala.concurrent.{Await, Future}
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global

def ageNextYear(currentAge: Int): Future[Int] = {
  Future { currentAge + 1 }
}

def welcome(name: String, age: Int): Future[String] = {
  Future { s&amp;quot;$name $age&amp;quot; }
}

val f = for {
  age &amp;lt;- ageNextYear(25)
  message &amp;lt;- welcome(&amp;quot;Michal&amp;quot;, age)
} yield s&amp;quot;$message nextYear: $age&amp;quot;

Await.result(f, 1.second) // Michal 26 nextYear: 26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Await.result&lt;/code&gt; is blocking operation.&lt;/p&gt;

&lt;h3 id=&#34;diffrence-between-and-in-for-comprehension&#34;&gt;Diffrence between &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;-&lt;/code&gt; in for comprehension&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val a = Some(2)
val b = Some(3)

for {
  v1 &amp;lt;- a
  v2 &amp;lt;- b //v2 is Int
} yield v1 + v2

for {
  v1 &amp;lt;- a
  v2 = b // v2 is Option[Int]
} yield v1 // + v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;-&lt;/code&gt; will &amp;ldquo;unpack&amp;rdquo;, &lt;code&gt;=&lt;/code&gt; is simple assigment.&lt;/p&gt;

&lt;h3 id=&#34;try-object-trait&#34;&gt;&lt;code&gt;Try&lt;/code&gt; object/trait&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scala.util.Try

val s = Try(&amp;quot;100&amp;quot;.toInt) // Success(100)
val f = Try(&amp;quot;michal&amp;quot;.toInt) // Failure(java.lang.NumberFormatException ...)

s.map(_ + 200) // Success(300)
f.map(_ + 200) // Failure(java.lang.NumberFormatException ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;a href=&#34;http://www.scalactic.org/&#34;&gt;scalactic&lt;/a&gt; you can use &lt;code&gt;String Or ErrorMessage&lt;/code&gt; (&lt;code&gt;Good(...)&lt;/code&gt;, &lt;code&gt;Bad(...)&lt;/code&gt; subclasses).&lt;/p&gt;

&lt;h3 id=&#34;if-in-for-comprehension&#34;&gt;&lt;code&gt;if&lt;/code&gt; in for-comprehension&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;var ll = List(List(1, 2, 3), List(2, 3), List(1), List(9), List(11, 1))

for {
  l &amp;lt;- ll
  e &amp;lt;- l if l.contains(1)
} yield e // List(1, 2, 3, 1, 11, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use &lt;code&gt;if&lt;/code&gt; in for-comprehension.
Every for-comprehension can be replaced with &lt;code&gt;flatMap&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; (outer iteration is &lt;code&gt;flatMap&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;filter-vs-withfilter&#34;&gt;&lt;code&gt;filter&lt;/code&gt; vs &lt;code&gt;withFilter&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;filter&lt;/code&gt; always returns collections. &lt;code&gt;withFilter&lt;/code&gt; returns generator. You can &amp;ldquo;join&amp;rdquo; join many generators.&lt;/p&gt;

&lt;p&gt;You should &lt;code&gt;withFilter&lt;/code&gt; when you have many filters.&lt;/p&gt;

&lt;h3 id=&#34;class-modifiers&#34;&gt;Class modifiers&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;final class Animal&lt;/code&gt; you cannnot extend Animal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sealed&lt;/code&gt; all subtypes must be defined in this file. &lt;code&gt;sealed&lt;/code&gt; should be define when you use &lt;a href=&#34;http://en.wikipedia.org/wiki/Algebraic_data_type&#34;&gt;ADT (algebraic data types)&lt;/a&gt;. &lt;code&gt;sealed&lt;/code&gt; is very helpfull in pattern matching.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;traits-linearization&#34;&gt;Traits linearization&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait A {
  def m: String
}
trait B extends A {
  override def m: String = &amp;quot;b&amp;quot;
  def b = &amp;quot;b&amp;quot;
}
trait C extends A {
  override def m: String = &amp;quot;c&amp;quot;
  def c = &amp;quot;c&amp;quot;
}

class BC extends B with C
class CB extends C with B

new BC().m // c
new CB().m // b
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;const-pattern-mattching&#34;&gt;Const Pattern Mattching&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def pattern(value: String, consToMatch: String): String = {
  val a = &amp;quot;1&amp;quot;
  val b = &amp;quot;2&amp;quot;
  value match {
    case `a` =&amp;gt; &amp;quot;one&amp;quot;
    case `b` =&amp;gt; &amp;quot;two&amp;quot;
    case `consToMatch` =&amp;gt; &amp;quot;!!!&amp;quot;
    case _ =&amp;gt; &amp;quot;???&amp;quot;
  }
}

pattern(&amp;quot;1&amp;quot;, &amp;quot;3&amp;quot;) // one
pattern(&amp;quot;3&amp;quot;, &amp;quot;3&amp;quot;) // !!!
pattern(&amp;quot;3&amp;quot;, &amp;quot;xxx&amp;quot;) // ???
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;others&#34;&gt;Others&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In subclass you can replace &lt;code&gt;def&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;There is type &lt;code&gt;Either&lt;/code&gt; and &lt;code&gt;Options&lt;/code&gt; - very usefull to handle errors or null pointers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lazy val&lt;/code&gt; can caused some problems. Instead of &lt;code&gt;lazy val&lt;/code&gt; maybe yhou should use &lt;code&gt;def&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&amp;quot;...&amp;quot;&lt;/code&gt; - string interpolation, &lt;code&gt;f&amp;quot;...&amp;quot;&lt;/code&gt; - formating (&lt;code&gt;f&amp;quot;$value%02x&amp;quot;&lt;/code&gt; (300 -&amp;gt; 12c)).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;abstract class&lt;/code&gt;? In most cases &lt;code&gt;trait&lt;/code&gt; is better. The only reason to use &lt;code&gt;abstract class&lt;/code&gt; is when we have to use constructor params.&lt;/li&gt;
&lt;li&gt;If we ovverride method, it should call &lt;code&gt;super&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It is better to use simple &lt;code&gt;case classes&lt;/code&gt; than &lt;code&gt;Tuple&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Scala Traits in JavaScript</title>
      <link>https://michalkowol.github.io/posts/2014-10-23-traits-in-javascript/</link>
      <pubDate>Thu, 23 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/2014-10-23-traits-in-javascript/</guid>
      <description>&lt;p&gt;Traits:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function _extend(object, source) {
    for (var key in source) {
        if (source.hasOwnProperty(key)) {
            object[key] = source[key];
        }
    }
    return object;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function _with() {
    var self = {};
    var args = Array.prototype.slice.call(arguments);
    for (var i = 0; i &amp;lt; args.length; i++) {
        args[i](self);
    }
    self.super = _extend({}, self);
    return self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Traits example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var mtv = (function (mtv) {
    &#39;use strict&#39;;
 
    mtv.TraitA = function (self) {
        self.functionA = function () {
            console.log(&#39;[start]: TraitA.functionA&#39;);
            console.log(self.getModel());
            console.log(&#39;[end]: TraitA.functionA&#39;);
        };
 
        self.dummyModel = function () {
            console.log(&#39;[start]: TraitA.dummyModel&#39;);
            console.log(&#39;[end]: TraitA.dummyModel&#39;);
        };
    };
 
    mtv.TraitB = function (self) {
        self.functionB = function () {
            console.log(&#39;[start]: TraitB.functionB&#39;);
            console.log(self.getModel());
            console.log(&#39;[end]: TraitB.functionB&#39;);
        };
 
        self.dummyModel = function () {
            console.log(&#39;[start]: TraitB.dummyModel&#39;);
            console.log(&#39;[end]: TraitB.dummyModel&#39;);
        };
 
        self.onlyB = function () {
            console.log(&#39;[start]: TraitB.onlyB&#39;);
            console.log(&#39;[end]: TraitB.onlyB&#39;);
        };
    };
 
    mtv.classWithTraitATraitB = function (model) {
        var self = _with(mtv.TraitA, mtv.TraitB);
 
        self.getModel = function () {
            console.log(&#39;[start]: classWithTraitATraitB.getModel&#39;);
            console.log(&#39;[end]: classWithTraitATraitB.getModel&#39;);
            return model;
        };
 
        self.functionB = function () {
            console.log(&#39;[start]: classWithTraitATraitB.functionB&#39;);
            self.super.functionB();
            self.functionA();
            console.log(&#39;[end]: classWithTraitATraitB.functionB&#39;);
        };
 
        return self;
    };
 
    var classA = mtv.classWithTraitATraitB(&#39;model&#39;);
    classA.functionA();
    classA.functionB();
    classA.dummyModel();
    return mtv;
})(mtv || {});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[start]: TraitA.functionA
[start]: classWithTraitATraitB.getModel
[end]: classWithTraitATraitB.getModel
model
[end]: TraitA.functionA
[start]: classWithTraitATraitB.functionB
[start]: TraitB.functionB
[start]: classWithTraitATraitB.getModel
[end]: classWithTraitATraitB.getModel
model
[end]: TraitB.functionB
[start]: TraitA.functionA
[start]: classWithTraitATraitB.getModel
[end]: classWithTraitATraitB.getModel
model
[end]: TraitA.functionA
[end]: classWithTraitATraitB.functionB
[start]: TraitB.dummyModel
[end]: TraitB.dummyModel
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>&#34;Closures&#34; in JavaScript</title>
      <link>https://michalkowol.github.io/posts/2014-07-22-closures-in-javascript/</link>
      <pubDate>Tue, 22 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/2014-07-22-closures-in-javascript/</guid>
      <description>&lt;p&gt;Closures in JS can simulate classes. Polymorphism, encapsulation and inheritance are avilable in this aproach.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function _extend(object, source) {
    for (var key in source) {
        if (source.hasOwnProperty(key)) {
            object[key] = source[key];
        }
    }
    return object;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var mtv = (function (mtv) {
    &#39;use strict&#39;;
 
    mtv.ClassA = function (a) {
        var self = {};
        self.a = a;
 
        function privateInA () {
            console.log(&#39;ClassA.privateInA.start&#39;);
            console.log(self.a);
            console.log(&#39;ClassA.privateInA.end&#39;);
        }
 
        self.bar = function () {
            console.log(&#39;ClassA.bar.start&#39;);
            self.foo();
            privateInA();
            console.log(&#39;ClassA.bar.end&#39;);
        };
 
        self.foo = function () {
            console.log(&#39;ClassA.foo.start&#39;);
            console.log(self.a);
            console.log(&#39;ClassA.foo.end&#39;);
        };
 
        self.changeA = function () {
            console.log(&#39;ClassA.changeA.start&#39;);
            self.a = self.a + &#39; Kowol&#39;;
            console.log(&#39;ClassA.changeA.end&#39;);
        };
 
        return self;
    };
 
    mtv.ClassB = function (b) {
        var self = mtv.ClassA(b);
        var _super = _extend({}, self);
        self.b = b;
 
        self.foo = function () {
            console.log(&#39;ClassB.foo.start&#39;);
            console.log(self.b + &#39; &#39; + self.a);
            _super.foo();
            console.log(&#39;ClassB.foo.end&#39;);
        };
 
        return self;
    };
 
    return mtv;
})(mtv || {});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var classB = mtv.ClassB(&#39;Michal&#39;);
classB.foo();       // ClassB.foo.start
                    // Michal Michal
                    // ClassA.foo.start
                    // Michal
                    // ClassA.foo.end
                    // ClassB.foo.end
 
classB.bar();       // ClassA.bar.start
                    // ClassB.foo.start
                    // Michal Michal
                    // ClassA.foo.start
                    // Michal
                    // ClassA.foo.end
                    // ClassB.foo.end
                    // ClassA.privateInA.start
                    // Michal
                    // ClassA.privateInA.end
                    // ClassA.bar.end
 
classB.changeA();   // ClassA.changeA.start
                    // ClassA.changeA.end
 
classB.bar();       // ClassA.bar.start
                    // ClassB.foo.start
                    // Michal Michal Kowol
                    // ClassA.foo.start
                    // Michal Kowol
                    // ClassA.foo.end
                    // ClassB.foo.end
                    // ClassA.privateInA.start
                    // Michal Kowol
                    // ClassA.privateInA.end
                    // ClassA.bar.end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>&#34;Classes&#34; and Singletions in JavaScript</title>
      <link>https://michalkowol.github.io/posts/2014-04-24-classes-and-singletions-in-javascript/</link>
      <pubDate>Thu, 24 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/2014-04-24-classes-and-singletions-in-javascript/</guid>
      <description>&lt;p&gt;In JS there are a lot of way to simulate classes. Here are examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var com = com || {};

com.MTVClass1 = function (videoID) {
    &amp;quot;use strict&amp;quot;;
    var self = {};
 
    function bar() {
        return &amp;quot;bar&amp;quot; + videoID;
    }
 
    self.foo = function () {
        return &amp;quot;foo&amp;quot; + bar() + videoID;
    };
 
    return self;
};

com.MTVClass1(&amp;quot;123&amp;quot;).foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var com = com || {};
 
(function () {
    &#39;use strict&#39;;
 
    com.MTVClass2 = function (videoID) {
        this.videoID = videoID;
    };
 
    function bar() {
        return &amp;quot;bar&amp;quot;; // does not have access to videoID
    }
 
    com.MTVClass2.prototype.foo = function () {
        return &amp;quot;foo&amp;quot; + bar() + this.videoID;
    };
}());

new com.MTVClass2(&amp;quot;1234&amp;quot;).foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var com = com || {};
 
com.MTVClass3 = (function () {
    &#39;use strict&#39;;
 
    function MTVClass3(videoID) {
        this.videoID = videoID;
    }
 
    function bar() {
        return &amp;quot;bar&amp;quot;;  // does not have access to videoID
    }
 
    MTVClass3.prototype.foo = function () {
        return &amp;quot;foo&amp;quot; + bar() + this.videoID;
    };
 
    return MTVClass3;
}());

new com.MTVClass3(&amp;quot;123&amp;quot;).foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var com = com || {};
 
com.MTVClass4 = (function () {
    &#39;use strict&#39;;
 
    function MTVClass4(videoID) {
        this.videoID = videoID;
    }
 
    function bar(self) {
        return &amp;quot;bar&amp;quot; + self.videoID;
    }
 
    MTVClass4.prototype.foo = function () {
        return &amp;quot;foo&amp;quot; + bar(this) + this.videoID;
    };
 
    return MTVClass4;
}());

new com.MTVClass4(&amp;quot;123&amp;quot;).foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var com = com || {};
 
com.MTVObject = (function () {
    &amp;quot;use strict&amp;quot;;
    var self = {};
 
    function bar() {
        return &amp;quot;bar&amp;quot;;
    }
 
    self.foo = function () {
        return &amp;quot;foo&amp;quot; + bar();
    };
 
    return self;
}());

com.MTVObject.foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my option &lt;code&gt;MTVClass1.js&lt;/code&gt; approach is the best one. &lt;code&gt;MTVClass1.js&lt;/code&gt; has similar concept like &lt;code&gt;MTVObject.js&lt;/code&gt;. In &lt;code&gt;MTVClass2.js&lt;/code&gt; and &lt;code&gt;MTVClass3.js&lt;/code&gt; you do not have access to class fields. &lt;code&gt;MTVClass1.js&lt;/code&gt; has some small performance issue, but remeber:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Premature optimization is the root of all evil.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Java with Spring</title>
      <link>https://michalkowol.github.io/posts/2013-12-05-java-with-spring/</link>
      <pubDate>Thu, 05 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/2013-12-05-java-with-spring/</guid>
      <description>

&lt;h2 id=&#34;simple-example&#34;&gt;Simple example:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
 
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
    xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
    xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&amp;quot;&amp;gt;
 
    &amp;lt;bean id=&amp;quot;apple&amp;quot; class=&amp;quot;Apple&amp;quot; /&amp;gt;
    &amp;lt;bean id=&amp;quot;juicer&amp;quot; class=&amp;quot;Juicer&amp;quot;&amp;gt;
        &amp;lt;constructor-arg ref=&amp;quot;apple&amp;quot; /&amp;gt;
        &amp;lt;constructor-arg ref=&amp;quot;peeler&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&amp;quot;peeler&amp;quot; class=&amp;quot;Peeler&amp;quot;&amp;gt;
        &amp;lt;constructor-arg ref=&amp;quot;apple&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- ... --&amp;gt;
&amp;lt;bean id=&amp;quot;juicer&amp;quot; class=&amp;quot;Juicer&amp;quot; scope=&amp;quot;prototype&amp;quot;&amp;gt;
&amp;lt;!-- ... --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Fruit {
    void eat();
    String getName();
}

public interface Peelable {
    void peel();
}

public class Apple implements Fruit, Peelable {
    public void peel() { }
    public void eat() { }
    String getName() { return &amp;quot;apple&amp;quot;; }
}

public class Peeler {
    private final Peelable peelable;
 
    public Peeler(Peelable peelable) {
        this.peelable = peelable;
    }
}

public class Juicer {
    private final Peelable peelable;
    private final Peeler peeler;
 
    public Juicer(Peelable peelable, Peeler peeler) {
        this.peelable = peelable;
        this.peeler = peeler;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MainAppPrototype {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;beans_prototype.xml&amp;quot;);
        Juicer j1 = context.getBean(Juicer.class);
        Juicer j2 = context.getBean(Juicer.class);
        System.out.println(j1 == j2);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MainAppSingleton {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);
        Juicer j1 = context.getBean(Juicer.class);
        Juicer j2 = context.getBean(Juicer.class);
        System.out.println(j1 == j2);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MainAppSingleton&lt;/code&gt; execution result: &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MainAppPrototype&lt;/code&gt; execution result: &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;resolving-conflicts-in-constructor-s-arguments&#34;&gt;Resolving conflicts in constructor&amp;rsquo;s arguments.&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;test&amp;quot; class=&amp;quot;Test&amp;quot;&amp;gt;
    &amp;lt;constructor-arg value=&amp;quot;xhajs&amp;quot; /&amp;gt;
    &amp;lt;constructor-arg value=&amp;quot;md5&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;test&amp;quot; class=&amp;quot;Test&amp;quot;&amp;gt;
    &amp;lt;constructor-arg name=&amp;quot;password&amp;quot; value=&amp;quot;xhajs&amp;quot; /&amp;gt;
    &amp;lt;constructor-arg value=&amp;quot;md5&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
 
    private String type;
    private String password;
 
    public Test(String type, String password) {
        this.type = type;
        this.password = password;
    }
     
    public String getPassword() {
        return password;
    }
     
    public String getType() {
        return type;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With &lt;code&gt;bean1.xml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Test.type = xhajs
Test.password= md5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With &lt;code&gt;bean2.xml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Test.type = md5
Test.password= xhajs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;factories&#34;&gt;Factories&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
 
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
    xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
    xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&amp;quot;&amp;gt;
 
    &amp;lt;bean id=&amp;quot;fruit&amp;quot; class=&amp;quot;Fruits&amp;quot; factory-method=&amp;quot;newBanana&amp;quot; /&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Fruit {
    void eat();
    String getName();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class Fruits {
 
    private Fruits() {
    }
     
    public static Fruit createFruit(String fruitName) {
        if (fruitName.equals(&amp;quot;banana&amp;quot;)) {
            return newBanana();
        } else {
            return newPlum(&amp;quot;defaultName&amp;quot;);
        }
    }
     
    public static Fruit newBanana() {
        return new Banana();
    }
     
    public static Fruit newPlum(String name) {
        return new Plum(name);
    }
     
    private static class Banana implements Fruit {
 
        public void eat() {
            System.out.println(&amp;quot;Eating a banana: omomom&amp;quot;);
        }
 
        public String getName() {
            return &amp;quot;banana&amp;quot;;
        }
    }
     
    private static class Plum implements Fruit {
 
        private String name;
 
        public Plum(String name) {
            this.name = name;
        }
 
        public void eat() {
            System.out.println(String.format(&amp;quot;Eating a plum %s: omomom&amp;quot;, name) );
        }
 
        public String getName() {
            return &amp;quot;plum&amp;quot;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MainApp {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);
        Fruit fruit = context.getBean(Fruit.class);
        fruit.eat();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Eating a banana: omomom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plum with name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;fruit&amp;quot; class=&amp;quot;Fruits&amp;quot; factory-method=&amp;quot;newPlum&amp;quot;&amp;gt;
    &amp;lt;constructor-arg value=&amp;quot;sliwka&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Eating a plum sliwka: omomom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plum by name using createFruit method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;fruit&amp;quot; class=&amp;quot;Fruits&amp;quot; factory-method=&amp;quot;createFruit&amp;quot;&amp;gt;
    &amp;lt;constructor-arg value=&amp;quot;sliwka&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Eating a plum defaultName: omomom
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Java puzzle</title>
      <link>https://michalkowol.github.io/posts/2013-11-22-java-puzzle/</link>
      <pubDate>Fri, 22 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/2013-11-22-java-puzzle/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s consider code bellow&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ClassMain {
 
  private val mainVar = &amp;quot;Main&amp;quot;
  showMeTheMain()
 
  protected def showMeTheMain() {
    println(mainVar)
  }
}
 
class ClassA extends ClassMain {
 
  private val a = &amp;quot;qwerty&amp;quot;
  showMeTheMain()
 
  override def showMeTheMain() {
    println(&amp;quot;not main anymore&amp;quot; + a.toUpperCase())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Result of this code is &lt;code&gt;NullPointerException&lt;/code&gt;. This is because we override method &lt;code&gt;showMeTheMain&lt;/code&gt;, but we want to use &lt;code&gt;a&lt;/code&gt; parameter.&lt;/p&gt;

&lt;p&gt;This is how program is executed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Constructor of &lt;code&gt;ClassMain&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Method &lt;code&gt;ClassA.showMeTheMain&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Constructor of &lt;code&gt;ClassA&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this example we changed access qualification from protected to public. We can increase access qualification, but we cannot make it more restrict.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>