<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Michał Kowol | Tech Blog</title>
    <link>https://michalkowol.github.io/tags/scala/index.xml</link>
    <description>Recent content on Michał Kowol | Tech Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://michalkowol.github.io/tags/scala/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Akka (notes, part 1)</title>
      <link>https://michalkowol.github.io/posts/akka-notes-part-1/</link>
      <pubDate>Mon, 01 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/akka-notes-part-1/</guid>
      <description>

&lt;h3 id=&#34;akka-traits&#34;&gt;Akka traits&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://michalkowol.github.io/img/akka-notes/reactive-traits.svg&#34; alt=&#34;akka traits&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Akka has 4 main traits. Those are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Responsive - the system responds very fast.&lt;/li&gt;
&lt;li&gt;Resilient - the system stays responsive in the face of failure.&lt;/li&gt;
&lt;li&gt;Elastic - the system stays responsive under varying workload. You can easily add/remove nodes (machines) to/from system.&lt;/li&gt;
&lt;li&gt;Message Driven - object talks through messages. Objects are loosely coupled. There is a big diffrence between event and message - every message has recipient address, but events don&amp;rsquo;t have to have it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please see &lt;a href=&#34;http://www.reactivemanifesto.org/&#34;&gt;Reactive Manifesto&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h3 id=&#34;concurrency-vs-parallelism&#34;&gt;Concurrency vs parallelism&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Definition 1

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Concurrency&lt;/strong&gt; is when two tasks can start, run, and complete in overlapping time periods. It doesn&amp;rsquo;t necessarily mean they&amp;rsquo;ll ever both be running at the same instant. Eg. multitasking on a single-core machine.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parallelism&lt;/strong&gt; is when tasks literally run at the same time, eg. on a multicore processor.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Definition 2

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Concurrency&lt;/strong&gt; A condition that exists when at least two threads are making progress. A more generalized form of parallelism that can include time-slicing as a form of virtual parallelism.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parallelism&lt;/strong&gt; A condition that arises when at least two threads are executing simultaneously.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ref: &lt;a href=&#34;http://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&#34;&gt;stackoverflow.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Example&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Concurrency - two queues, one coffee machine&lt;/li&gt;
&lt;li&gt;Parallelism - two queues, two coffee machines&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://michalkowol.github.io/img/akka-notes/con_and_par.jpg&#34; alt=&#34;Concurrency vs Parallelism&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Source: &lt;a href=&#34;http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html&#34;&gt;joearms.github.io&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;actor-actorref&#34;&gt;Actor, ActorRef&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://michalkowol.github.io/img/akka-notes/actor-ref.png&#34; alt=&#34;Actor with Mailbox&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each actor has dispatcher and mailbox.&lt;/li&gt;
&lt;li&gt;If we send message to actor, it will add message to its mailbox and it will return &lt;strong&gt;immediately&lt;/strong&gt; - this is not blocking operation.&lt;/li&gt;
&lt;li&gt;If we create actor, &lt;code&gt;actorOf&lt;/code&gt; will return &lt;strong&gt;immediately&lt;/strong&gt; &lt;code&gt;ActorRef&lt;/code&gt;. It does not wait to create an instance. If we send messages to actor that is &amp;ldquo;not started&amp;rdquo;, messages will be added to mailbox and will be processed when actor is inicialized - we will not lose any message.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dispatcher&lt;/code&gt; assigns (schedules) thread to process the message.&lt;/li&gt;
&lt;li&gt;Many actors have the same dispatcher - it is some kind of thread pool.&lt;/li&gt;
&lt;li&gt;One message is passed to the actor&lt;/li&gt;
&lt;li&gt;Only &lt;strong&gt;one&lt;/strong&gt; thread can be in &lt;strong&gt;receive&lt;/strong&gt; block (&amp;ldquo;single-threaded illusion&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;Actors could have mutable state (but rember not to share mutable state!).&lt;/li&gt;
&lt;li&gt;Messages must be immutable.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;how-to-handle-unhandled-messages&#34;&gt;How to handle &amp;ldquo;unhandled&amp;rdquo; messages&lt;/h3&gt;

&lt;p&gt;If in receive block we do not handle some message, this message will be dropped (and maybe logged). We can use &lt;code&gt;unhandled&lt;/code&gt; method to do something with messages not handled in receive block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;override def unhandled(message: Any): Unit = ???
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;top-level-actor&#34;&gt;Top-Level Actor&lt;/h3&gt;

&lt;p&gt;If you create top-level actors, use factory methods - it will simplify testing. Always give name to your top-level actors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val topLevelActor = createTopLevelActor()
def createTopLevelActor(): ActorRef = system.actorOf(TopLevel.props, &amp;quot;top-level&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;message-protocol&#34;&gt;Message protocol&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Defince your message protocol in the companion object of the actor.&lt;/li&gt;
&lt;li&gt;If you use message protocol from other actor, use actor name as prefix to this message - this will make code more readable.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object FooActor {
  case object FooMessage
}
class FooActor extends Actor {
  import FooActor._
  override def receive: Receive = {
    case FooMessage =&amp;gt; ???
    case BarActor.BarMessage =&amp;gt; ???
  }
}

object BarActor {
  case object BarMessage
}
class BarActor extends Actor {
  import BarActor._
  override def receive: Receive = {
    case FooActor.FooMessage =&amp;gt; ???
    case BarMessage =&amp;gt; ???
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;actor-dsl&#34;&gt;Actor DSL&lt;/h3&gt;

&lt;p&gt;To create anonymous actoes we can use &lt;a href=&#34;http://doc.akka.io/docs/akka/2.3.0-RC1/scala/actordsl.html&#34;&gt;Actor DSL&lt;/a&gt;. Here, &lt;code&gt;actor&lt;/code&gt; takes the role of either &lt;code&gt;system.actorOf&lt;/code&gt; or &lt;code&gt;context.actorOf&lt;/code&gt;. It takes an implicit &lt;code&gt;ActorRefFactory&lt;/code&gt; and creates the new &lt;code&gt;Actor&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import akka.actor.ActorDSL._
 
val a = actor(new Act {
  become {
    case &amp;quot;hello&amp;quot; =&amp;gt; sender() ! &amp;quot;hi&amp;quot;
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;best-practices&#34;&gt;Best practices&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Always create &lt;code&gt;Props&lt;/code&gt; factory - the best place for that is in companion object (see: &lt;a href=&#34;http://doc.akka.io/docs/akka/snapshot/scala/actors.html&#34;&gt;Actors — Akka Documentation&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Put Companion Object before you class.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;sender()&lt;/code&gt; &lt;strong&gt;with&lt;/strong&gt; parentheses. It is function, not val and you have to rember about it. It can be very tricky when &lt;code&gt;sender()&lt;/code&gt; will be execute in other thread - in example in &lt;code&gt;Future&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class WrongWayActor extends Actor {
  override def receive: Receive = {
    case _ =&amp;gt; Future {
      val result = doSomeHeavyComputation
      sender() ! result // if you reacive other message in meantime, it will send the response to WRONG actor
    }
  }
}
 
class GoodWayActor extends Actor {
  override def receive: Receive = {
    case _ =&amp;gt;
      val originalSender = sender()
      Future {
        val result = doSomeHeavyComputation
        originalSender ! result  // it closes clouser over - it will send response to right actor
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scala (notes)</title>
      <link>https://michalkowol.github.io/posts/scala-notes/</link>
      <pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/scala-notes/</guid>
      <description>

&lt;h3 id=&#34;functions-without-parameters&#34;&gt;Functions without parameters&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def foo: String = ???
def bar(): String = ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first one is better, bacause you can easly replace it with &lt;code&gt;val&lt;/code&gt;. In fact, otheres developers shouldn&amp;rsquo;t know if you use &lt;code&gt;val&lt;/code&gt; or &lt;code&gt;def&lt;/code&gt;. It should be transparent (you shouldn&amp;rsquo;t use parentheses).&lt;/p&gt;

&lt;h3 id=&#34;default-parameters&#34;&gt;Default parameters&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Welcome(message: String = &amp;quot;default&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;public-api&#34;&gt;Public API&lt;/h3&gt;

&lt;p&gt;If we define public API, all methods and parameters should have explicite type.&lt;/p&gt;

&lt;h3 id=&#34;operators&#34;&gt;Operators&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1 + 3 == (1).+(3)
!true == true.unary_!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To be consisten:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;all operators like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, etc. should be used with infix notation,&lt;/li&gt;
&lt;li&gt;in other cases we &lt;strong&gt;should&lt;/strong&gt; use dot notation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;named-parameters&#34;&gt;Named parameters&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;case class User(name: String, lastname: String)
User(name = &amp;quot;Michal&amp;quot;, lastname = &amp;quot;Kowol&amp;quot;) == User(lastname = &amp;quot;Kowol&amp;quot;, name = &amp;quot;Michal&amp;quot;) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we have a lot of parameters (especially with the same type - integers and strings), we should used named parameters. It makes code more readable and more expressible.&lt;/p&gt;

&lt;h3 id=&#34;imports-in-code-s-block-are-ok&#34;&gt;Imports in code&amp;rsquo;s block are ok&lt;/h3&gt;

&lt;p&gt;If you need specific import only in one function, import it in function body.&lt;/p&gt;

&lt;h3 id=&#34;private-access-modifiers-in-scala&#34;&gt;Private access modifiers in Scala&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package com.michal

class A {
  private def defaultPrivate = ???
  private [this] def superPrivate(other: A) {
    //other.superPrivate(this) // error
    other.defaultPrivate
    superPrivate(other)
  }
  private [michal] def publicInPackage = ???
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package com.michal

class B {
  def test(a: A) = {
    a.publicInPackage
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package com

import com.michal.A

class C {
  def test(a: A) {
    // a.publicInPackage
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;private [this]&lt;/code&gt; is very restrict. It can be be called only in &amp;ldquo;this&amp;rdquo;. You can use package access modifier (it could be good for tests).&lt;/p&gt;

&lt;h3 id=&#34;should-i-extend-app-or-should-i-use-main-args-array-string&#34;&gt;Should I extend &lt;code&gt;App&lt;/code&gt; or should I use &lt;code&gt;main(args: Array[String])&lt;/code&gt;?&lt;/h3&gt;

&lt;p&gt;Extending &lt;code&gt;App&lt;/code&gt; is code for prototyping. In production you should use &lt;code&gt;main&lt;/code&gt;. Why?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Whole object body is treatead as main,&lt;/li&gt;
&lt;li&gt;you don&amp;rsquo;t hava access to args,&lt;/li&gt;
&lt;li&gt;&lt;blockquote&gt;It should be noted that this trait is implemented using the DelayedInit functionality, which means that fields of the object will not have been initialized before the main method has been executed.&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;copy-method-in-case-classes&#34;&gt;&lt;code&gt;copy&lt;/code&gt; method in case classes&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class User(name: String, age: Int)
User(name = &amp;quot;Bob&amp;quot;, age = 10).copy(age = 40) // User(Bob, 40)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;list-vs-vector&#34;&gt;List vs Vector&lt;/h3&gt;

&lt;h4 id=&#34;list&#34;&gt;List&lt;/h4&gt;

&lt;p&gt;List has only pointer to first element - it adds very fast to head of list. To add element to end of list it has to iterate throught all elements (&lt;code&gt;O(n)&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;vector&#34;&gt;Vector&lt;/h4&gt;

&lt;p&gt;All operations are constant in time (even putting element in the middile of collection).&lt;/p&gt;

&lt;h5 id=&#34;performance-characteristics&#34;&gt;Performance characteristics&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://michalkowol.github.io/img/scala-notes/performance.png&#34; alt=&#34;performance characteristics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;Performance characteristics&#34;&gt;Performance characteristics&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;seq-is-mutable&#34;&gt;&lt;code&gt;Seq&lt;/code&gt; is mutable!&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val s = Array(1 ,2, 3) // s: Array[Int] = Array(1, 2, 3)
def testCase(s: Seq[Int]) = s // testCase: TestCase[](val s: Seq[Int]) =&amp;gt; Seq[Int]
testCase(s) // res0: Seq[Int] = WrappedArray(1, 2, 3)
s(0) = 7 // res1: Unit = ()
testCase(s) // res2: Seq[Int] = WrappedArray(7, 2, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is at least one mutable subtype of &lt;code&gt;Seq&lt;/code&gt;: &lt;code&gt;WrappedArray&lt;/code&gt;. To be sure sequence is immutable use &lt;code&gt;scala.collection.immutable.Seq&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;future&#34;&gt;Future&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scala.concurrent.{Await, Future}
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global

def ageNextYear(currentAge: Int): Future[Int] = {
  Future { currentAge + 1 }
}

def welcome(name: String, age: Int): Future[String] = {
  Future { s&amp;quot;$name $age&amp;quot; }
}

val f = for {
  age &amp;lt;- ageNextYear(25)
  message &amp;lt;- welcome(&amp;quot;Michal&amp;quot;, age)
} yield s&amp;quot;$message nextYear: $age&amp;quot;

Await.result(f, 1.second) // Michal 26 nextYear: 26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Await.result&lt;/code&gt; is blocking operation.&lt;/p&gt;

&lt;h3 id=&#34;diffrence-between-and-in-for-comprehension&#34;&gt;Diffrence between &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;-&lt;/code&gt; in for comprehension&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val a = Some(2)
val b = Some(3)

for {
  v1 &amp;lt;- a
  v2 &amp;lt;- b //v2 is Int
} yield v1 + v2

for {
  v1 &amp;lt;- a
  v2 = b // v2 is Option[Int]
} yield v1 // + v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;-&lt;/code&gt; will &amp;ldquo;unpack&amp;rdquo;, &lt;code&gt;=&lt;/code&gt; is simple assigment.&lt;/p&gt;

&lt;h3 id=&#34;try-object-trait&#34;&gt;&lt;code&gt;Try&lt;/code&gt; object/trait&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scala.util.Try

val s = Try(&amp;quot;100&amp;quot;.toInt) // Success(100)
val f = Try(&amp;quot;michal&amp;quot;.toInt) // Failure(java.lang.NumberFormatException ...)

s.map(_ + 200) // Success(300)
f.map(_ + 200) // Failure(java.lang.NumberFormatException ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;a href=&#34;http://www.scalactic.org/&#34;&gt;scalactic&lt;/a&gt; you can use &lt;code&gt;String Or ErrorMessage&lt;/code&gt; (&lt;code&gt;Good(...)&lt;/code&gt;, &lt;code&gt;Bad(...)&lt;/code&gt; subclasses).&lt;/p&gt;

&lt;h3 id=&#34;if-in-for-comprehension&#34;&gt;&lt;code&gt;if&lt;/code&gt; in for-comprehension&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;var ll = List(List(1, 2, 3), List(2, 3), List(1), List(9), List(11, 1))

for {
  l &amp;lt;- ll
  e &amp;lt;- l if l.contains(1)
} yield e // List(1, 2, 3, 1, 11, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use &lt;code&gt;if&lt;/code&gt; in for-comprehension.
Every for-comprehension can be replaced with &lt;code&gt;flatMap&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; (outer iteration is &lt;code&gt;flatMap&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;filter-vs-withfilter&#34;&gt;&lt;code&gt;filter&lt;/code&gt; vs &lt;code&gt;withFilter&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;filter&lt;/code&gt; always returns collections. &lt;code&gt;withFilter&lt;/code&gt; returns generator. You can &amp;ldquo;join&amp;rdquo; join many generators.&lt;/p&gt;

&lt;p&gt;You should &lt;code&gt;withFilter&lt;/code&gt; when you have many filters.&lt;/p&gt;

&lt;h3 id=&#34;class-modifiers&#34;&gt;Class modifiers&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;final class Animal&lt;/code&gt; you cannnot extend Animal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sealed&lt;/code&gt; all subtypes must be defined in this file. &lt;code&gt;sealed&lt;/code&gt; should be define when you use &lt;a href=&#34;http://en.wikipedia.org/wiki/Algebraic_data_type&#34;&gt;ADT (algebraic data types)&lt;/a&gt;. &lt;code&gt;sealed&lt;/code&gt; is very helpfull in pattern matching.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;traits-linearization&#34;&gt;Traits linearization&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait A {
  def m: String
}
trait B extends A {
  override def m: String = &amp;quot;b&amp;quot;
  def b = &amp;quot;b&amp;quot;
}
trait C extends A {
  override def m: String = &amp;quot;c&amp;quot;
  def c = &amp;quot;c&amp;quot;
}

class BC extends B with C
class CB extends C with B

new BC().m // c
new CB().m // b
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;const-pattern-mattching&#34;&gt;Const Pattern Mattching&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def pattern(value: String, consToMatch: String): String = {
  val a = &amp;quot;1&amp;quot;
  val b = &amp;quot;2&amp;quot;
  value match {
    case `a` =&amp;gt; &amp;quot;one&amp;quot;
    case `b` =&amp;gt; &amp;quot;two&amp;quot;
    case `consToMatch` =&amp;gt; &amp;quot;!!!&amp;quot;
    case _ =&amp;gt; &amp;quot;???&amp;quot;
  }
}

pattern(&amp;quot;1&amp;quot;, &amp;quot;3&amp;quot;) // one
pattern(&amp;quot;3&amp;quot;, &amp;quot;3&amp;quot;) // !!!
pattern(&amp;quot;3&amp;quot;, &amp;quot;xxx&amp;quot;) // ???
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;others&#34;&gt;Others&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In subclass you can replace &lt;code&gt;def&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;There is type &lt;code&gt;Either&lt;/code&gt; and &lt;code&gt;Options&lt;/code&gt; - very usefull to handle errors or null pointers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lazy val&lt;/code&gt; can caused some problems. Instead of &lt;code&gt;lazy val&lt;/code&gt; maybe yhou should use &lt;code&gt;def&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&amp;quot;...&amp;quot;&lt;/code&gt; - string interpolation, &lt;code&gt;f&amp;quot;...&amp;quot;&lt;/code&gt; - formating (&lt;code&gt;f&amp;quot;$value%02x&amp;quot;&lt;/code&gt; (300 -&amp;gt; 12c)).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;abstract class&lt;/code&gt;? In most cases &lt;code&gt;trait&lt;/code&gt; is better. The only reason to use &lt;code&gt;abstract class&lt;/code&gt; is when we have to use constructor params.&lt;/li&gt;
&lt;li&gt;If we ovverride method, it should call &lt;code&gt;super&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It is better to use simple &lt;code&gt;case classes&lt;/code&gt; than &lt;code&gt;Tuple&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Scala traits in javascript</title>
      <link>https://michalkowol.github.io/posts/traits-in-javascript/</link>
      <pubDate>Thu, 23 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://michalkowol.github.io/posts/traits-in-javascript/</guid>
      <description>&lt;p&gt;Traits:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function _extend(object, source) {
    for (var key in source) {
        if (source.hasOwnProperty(key)) {
            object[key] = source[key];
        }
    }
    return object;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function _with() {
    var self = {};
    var args = Array.prototype.slice.call(arguments);
    for (var i = 0; i &amp;lt; args.length; i++) {
        args[i](self);
    }
    self.super = _extend({}, self);
    return self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Traits example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var mtv = (function (mtv) {
    &#39;use strict&#39;;
 
    mtv.TraitA = function (self) {
        self.functionA = function () {
            console.log(&#39;[start]: TraitA.functionA&#39;);
            console.log(self.getModel());
            console.log(&#39;[end]: TraitA.functionA&#39;);
        };
 
        self.dummyModel = function () {
            console.log(&#39;[start]: TraitA.dummyModel&#39;);
            console.log(&#39;[end]: TraitA.dummyModel&#39;);
        };
    };
 
    mtv.TraitB = function (self) {
        self.functionB = function () {
            console.log(&#39;[start]: TraitB.functionB&#39;);
            console.log(self.getModel());
            console.log(&#39;[end]: TraitB.functionB&#39;);
        };
 
        self.dummyModel = function () {
            console.log(&#39;[start]: TraitB.dummyModel&#39;);
            console.log(&#39;[end]: TraitB.dummyModel&#39;);
        };
 
        self.onlyB = function () {
            console.log(&#39;[start]: TraitB.onlyB&#39;);
            console.log(&#39;[end]: TraitB.onlyB&#39;);
        };
    };
 
    mtv.classWithTraitATraitB = function (model) {
        var self = _with(mtv.TraitA, mtv.TraitB);
 
        self.getModel = function () {
            console.log(&#39;[start]: classWithTraitATraitB.getModel&#39;);
            console.log(&#39;[end]: classWithTraitATraitB.getModel&#39;);
            return model;
        };
 
        self.functionB = function () {
            console.log(&#39;[start]: classWithTraitATraitB.functionB&#39;);
            self.super.functionB();
            self.functionA();
            console.log(&#39;[end]: classWithTraitATraitB.functionB&#39;);
        };
 
        return self;
    };
 
    var classA = mtv.classWithTraitATraitB(&#39;model&#39;);
    classA.functionA();
    classA.functionB();
    classA.dummyModel();
    return mtv;
})(mtv || {});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[start]: TraitA.functionA
[start]: classWithTraitATraitB.getModel
[end]: classWithTraitATraitB.getModel
model
[end]: TraitA.functionA
[start]: classWithTraitATraitB.functionB
[start]: TraitB.functionB
[start]: classWithTraitATraitB.getModel
[end]: classWithTraitATraitB.getModel
model
[end]: TraitB.functionB
[start]: TraitA.functionA
[start]: classWithTraitATraitB.getModel
[end]: classWithTraitATraitB.getModel
model
[end]: TraitA.functionA
[end]: classWithTraitATraitB.functionB
[start]: TraitB.dummyModel
[end]: TraitB.dummyModel
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>