<!DOCTYPE html>
<html lang="pl"></html>
<head>
  <title>Michał Kowol</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="css/vendor.min.css"/>
  <link rel="stylesheet" href="css/style.min.css"/>
</head>
<body>
  <div class="container">
    <div class="posts">
      <article>
        <h1>Scala (notes)</h1>
        <div class="panel panel-default">
          <div class="panel-heading">2014-11-28 [Scala]</div>
          <div class="panel-body">
            <section>
              <header>
                <h4>Functions without parameters</h4>
              </header>
              <div>
                <script src="https://gist.github.com/michalkowol/8c9682823103c6813097.js"></script>
                <div>The first one is better, bacause you can easly replace it with <code>val</code>. In fact, otheres developers shouldn't know if you use <code>val</code> or <code>def</code>. It should be transparent (you shouldn't use parentheses).</div>
              </div>
            </section>
            <section>
              <h4>Default parameters</h4>
              <script src="https://gist.github.com/michalkowol/ec5c78769d9aab576d84.js"></script>
            </section>
            <section>
              <h4>Public API</h4>
              <div>If we define public API, all methods and parameters should have explicite type.</div>
            </section>
            <section>
              <h4>Operators</h4>
              <div>
                <script src="https://gist.github.com/michalkowol/ccfc2bdb0bb0a90dec56.js"></script>
                <div>To be consisten:</div>
                <ul>
                  <li>all operators like <code>+, !, -</code>, etc should be used with infix notation,</li>
                  <li>in other cases we <b>should</b> use dot notation.</li>
                </ul>
              </div>
            </section>
            <section>
              <h4>Named parameters</h4>
              <div>
                <script src="https://gist.github.com/michalkowol/fe5d0b8fa16a6857a2eb.js"></script>
                <div>When we have a lot of parameters (especially with the same type - integers and strings), we should used named parameters. It makes code more readable and more expressible.</div>
              </div>
            </section>
            <section>
              <h4>Imports in code's block are ok</h4>
              <div>If you need specific import only in one function, import it in function body.</div>
            </section>
            <section>
              <h4>Private access modifiers in Scala</h4>
              <div>
                <script src="https://gist.github.com/michalkowol/4965cc09b3b50c3c30a4.js"></script><code>private [this]</code> is very restrict. It can be be called only in "this". You can use package access modifier (it could be good for tests).
              </div>
            </section>
            <section>
              <h4>Should I extend <code>App</code> or should I use <code>main(args: Array[String])</code>?</h4>
              <div>Extending <code>App</code> is code for prototyping. In production you should use <code>main</code>. Why?
                <ul>
                  <li>Whole object body is treatead as main,</li>
                  <li>you don't hava access to <code>args</code>,</li>
                  <li>
                    <blockquote cite="http://www.scala-lang.org/api/current/index.html#scala.App" class="small">It should be noted that this trait is implemented using the DelayedInit functionality, which means that fields of the object will not have been initialized before the main method has been executed.</blockquote>
                  </li>
                </ul>
              </div>
            </section>
            <section>
              <h4><code>copy</code> method in case classes</h4>
              <script src="https://gist.github.com/michalkowol/0042b1d075075a483a5b.js"></script>
            </section>
            <section>
              <h4><code>List</code> vs <code>Vector</code></h4>
              <h5><code>List</code></h5>
              <div>List has only pointer to first element - it adds very fast to head of list. To add element to end of list it has to iterate throught all elements (<code>O(n)</code>).</div>
              <h5><code>Vector</code></h5>
              <div>All operations are constant in time (even putting element in the middile of collection).</div>
              <h5>Performance characteristics</h5>
              <div>
                <div><img src="img/performance.png" alt="Performance characteristics"></div><a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html">Performance characteristics</a>
              </div>
            </section>
            <section>
              <h4><code>Seq</code> is mutable!</h4>
              <div>
                <script src="https://gist.github.com/michalkowol/c8c78a917e8a794cfdf9.js"></script>
                <div>There is at least one mutable subtype of <code>Seq</code>: <code>WrappedArray</code>. To be sure sequence is immutable use <code>scala.collection.immutable.Seq</code>.</div>
              </div>
            </section>
            <section>
              <h4>Future</h4>
              <div>
                <script src="https://gist.github.com/michalkowol/21b648b8a1fae1da8123.js"></script>
                <div><code>Await.result</code> is blocking operation.</div>
              </div>
            </section>
            <section>
              <h4>Diffrence between <code>=</code> and <code>&lt;-</code> in for comprehension</h4>
              <div>
                <script src="https://gist.github.com/michalkowol/77cd21d39a09355c24f2.js"></script>
                <div><code>&lt;-</code> will "unpack", <code>=</code> is simple assigment.</div>
              </div>
            </section>
            <section>
              <h4><code>Try</code> object/trait</h4>
              <div>
                <script src="https://gist.github.com/michalkowol/e9446d855e33a5b6ce7c.js"></script>
                <div>In <a href="http://www.scalactic.org/">scalactic</a> you can use <code>String Or ErrorMessage</code> (<code>Good(...)</code>, <code>Bad(...)</code> subclasses).</div>
              </div>
            </section>
            <section>
              <h4><code>if</code> in for-comprehension</h4>
              <div>
                <script src="https://gist.github.com/michalkowol/e5e68fd31c78bf766506.js"></script>
                <div>You can use <code>if</code> in for-comprehension.</div>
                <div>Every for-comprehension can be replaced with <code>flatMap</code> and <code>map</code> (outer iteration is <code>flatMap</code>).</div>
              </div>
            </section>
            <section>
              <h4><code>filter</code> vs <code>withFilter</code></h4>
              <div>
                <div><code>filter</code> always returns collections. <code>withFilter</code> returns generator. You can "join" join many generators.</div>
                <div>You should <code>withFilter</code> when you have many filters.</div>
              </div>
            </section>
            <section>
              <h4>Class modifiers</h4>
              <ul>
                <li><code>final class Animal</code> you cannnot extend Animal</li>
                <li><code>sealed</code> All subtypes must be defined in this file. <code>sealed</code> should be define when you use <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">ADT (algebraic data types)</a>. <code>sealed</code> is very helpfull in pattern matching.</li>
              </ul>
            </section>
            <section>
              <h4>Traits linearization</h4>
              <script src="https://gist.github.com/michalkowol/8c329a089e5b1bcdd51a.js"></script>
            </section>
            <section>
              <h4>Const Pattern Mattching</h4>
              <script src="https://gist.github.com/michalkowol/e334f8bafff000e11549.js"></script>
            </section>
            <section>
              <h4>Others</h4>
              <ul>
                <li>In subclass you can replace <code>def</code> with <code>val</code>.</li>
                <li>There is type <code>Either</code> and <code>Options</code> - very usefull to handle errors or null pointers.</li>
                <li><code>lazy val</code> can caused some problems. Instead of <code>lazy val</code> maybe yhou should use <code>def</code>.</li>
                <li><code>s"..."</code> - string interpolation, <code>f"..."</code> - formating (<code>f"$value%02x"</code> (300 -&gt; 12c)).</li>
                <li><code>trait</code> or <code>abstract class</code>? In most cases <code>trait</code> is better. The only reason to use <code>abstract class</code> is when we have to use constructor params.</li>
                <li>If we ovverride method, it should call <code>super</code>.</li>
                <li>It is better to use simple <code>case classes</code> than <code>Tuple</code>.</li>
              </ul>
            </section>
          </div>
        </div>
      </article>
      <article>
        <h1>Traits like in JavaScript</h1>
        <div class="panel panel-default">
          <div class="panel-heading">2014-10-23 [JavaScript]</div>
          <div class="panel-body">
            <section>
              <h2>Traits:</h2>
              <script src="https://gist.github.com/michalkowol/f6ca3c360f703c370754.js"></script>
              <h2>Traits example:</h2>
              <script src="https://gist.github.com/michalkowol/4191620b733f0cbeb3ba.js"></script>
              <div>
                <h2>Result:</h2>
                <pre>[start]: TraitA.functionA
[start]: classWithTraitATraitB.getModel
[end]: classWithTraitATraitB.getModel
model
[end]: TraitA.functionA
[start]: classWithTraitATraitB.functionB
[start]: TraitB.functionB
[start]: classWithTraitATraitB.getModel
[end]: classWithTraitATraitB.getModel
model
[end]: TraitB.functionB
[start]: TraitA.functionA
[start]: classWithTraitATraitB.getModel
[end]: classWithTraitATraitB.getModel
model
[end]: TraitA.functionA
[end]: classWithTraitATraitB.functionB
[start]: TraitB.dummyModel
[end]: TraitB.dummyModel</pre>
              </div>
            </section>
          </div>
        </div>
      </article>
      <article>
        <h1>"Closures" in JavaScript</h1>
        <div class="panel panel-default">
          <div class="panel-heading">2014-07-22 [JavaScript]</div>
          <div class="panel-body">
            <section>
              <div>Closures in JS can simulate classes. Polymorphism, encapsulation and inheritance are avilable in this aproach.</div>
              <script src="https://gist.github.com/michalkowol/190559f3f92f9a8e4111.js"></script>
              <div>Example:
                <pre>var classB = mtv.ClassB('Michal');
classB.foo();       // ClassB.foo.start
                    // Michal Michal
                    // ClassA.foo.start
                    // Michal
                    // ClassA.foo.end
                    // ClassB.foo.end
 
classB.bar();       // ClassA.bar.start
                    // ClassB.foo.start
                    // Michal Michal
                    // ClassA.foo.start
                    // Michal
                    // ClassA.foo.end
                    // ClassB.foo.end
                    // ClassA.privateInA.start
                    // Michal
                    // ClassA.privateInA.end
                    // ClassA.bar.end
 
classB.changeA();   // ClassA.changeA.start
                    // ClassA.changeA.end
 
classB.bar();       // ClassA.bar.start
                    // ClassB.foo.start
                    // Michal Michal Kowol
                    // ClassA.foo.start
                    // Michal Kowol
                    // ClassA.foo.end
                    // ClassB.foo.end
                    // ClassA.privateInA.start
                    // Michal Kowol
                    // ClassA.privateInA.end
                    // ClassA.bar.end</pre>
              </div>
            </section>
          </div>
        </div>
      </article>
      <article>
        <h1>"Classes" and Singletions in JavaScript</h1>
        <div class="panel panel-default">
          <div class="panel-heading">2014-04-24 [JavaScript]</div>
          <div class="panel-body">
            <section>
              <div>In JS there are a lot of way to simulate classes. Here are examples:</div>
              <script src="https://gist.github.com/michalkowol/4e7791c0fe7d8f981d7a.js"></script>
              <div>In my option <code>MTVClass1.js</code> approach is the best one. <code>MTVClass1.js</code> has similar concept like <code>MTVObject.js</code>. In <code>MTVClass2.js</code> and <code>MTVClass3.js</code> you do not have access to class fields. <code>MTVClass1.js</code> has some small performance issue, but remeber:
                <blockquote cite="Donald Knuth" class="small">Premature optimization is the root of all evil.</blockquote>
              </div>
            </section>
          </div>
        </div>
      </article>
      <article>
        <h1>Java with Spring</h1>
        <div class="panel panel-default">
          <div class="panel-heading">2013-12-05 [Java, Spring, Bean]</div>
          <div class="panel-body">
            <section>
              <h4>Simple example:</h4>
              <div>
                <script src="https://gist.github.com/michalkowol/360bab621fa243e67894.js"></script>
                <div>MainAppSingleton execution result:
                  <pre>true</pre>
                </div>
                <div>MainAppPrototype execution result:
                  <pre>false</pre>
                </div>
              </div>
            </section>
            <section>
              <h4>Konstruktory i rozwiązywanie konfliktów</h4>
              <div>
                <script src="https://gist.github.com/michalkowol/dac25151507ca255a296.js"></script>
                <div>With <code>bean1.xml</code>
                  <pre>Test.type = xhajs
Test.password= md5</pre>
                </div>
                <div>With <code>bean2.xml</code>
                  <pre>Test.type = md5
Test.password= xhajs</pre>
                </div>
              </div>
            </section>
            <section>
              <h4>Factories
                <script src="https://gist.github.com/michalkowol/e45946dfe420ca729d1e.js"></script>
              </h4>
              <div>Result:
                <pre>Eating a banana: omomom</pre>
              </div>
              <div>Plum with name:
                <script src="https://gist.github.com/michalkowol/e98f76938ac98ccb0d26.js"></script>
                <pre>Eating a plum sliwka: omomom</pre>
              </div>
              <div>Plum by name using <code>createFruit</code> method:
                <script src="https://gist.github.com/michalkowol/4281a064f1daa72934b1.js"></script>
                <pre>Eating a plum defaultName: omomom</pre>
              </div>
            </section>
          </div>
        </div>
      </article>
      <article>
        <h1>Przeciążona metoda wywołana z konstruktora klasy bazowej</h1>
        <div class="panel panel-default">
          <div class="panel-heading">2013-11-22 [Java]</div>
          <div class="panel-body">
            <section>
              <div>Przeanalizujmy poniższy kod:</div>
              <script src="https://gist.github.com/michalkowol/e9e5f3f87338ddec829e.js"></script>
              <div>Efektem stworzenia ClassA będzie NullPointerException. Dzieje się to dlatego, że przeciążamy showMeTheMain, które chce skorzystać ze zmiennej a.</div>
              <div>Jak wykonuje się program:</div>
              <ol>
                <li>Konstruktor ClassMain.</li>
                <li>Metoda ClassA.showMeTheMain.</li>
                <li>Konstruktor ClassA.</li>
              </ol>
              <div>W tym przykładzie zmieniliśmy kwalifikator dostępu z protected na public. Zawsze można zwiększać, ale nie można zmniejszać (co jest logiczne).</div>
            </section>
          </div>
        </div>
      </article>
    </div>
  </div>
  <script src="js/app.min.js"></script>
</body>