
<h1>Scala (notes)</h1>
<div class="panel panel-default">
  <div class="panel-heading">2014-11-28 [Scala]</div>
  <div class="panel-body">
    <section>
      <header>
        <h4>Functions without parameters</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/8c9682823103c6813097.js"></script>
        <div>The first one is better, bacause you can easly replace it with <code>val</code>. In fact, otheres developers shouldn't know if you use <code>val</code> or <code>def</code>. It should be transparent (you shouldn't use parentheses).</div>
      </section>
    </section>
    <section>
      <header>
        <h4>Default parameters</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/ec5c78769d9aab576d84.js"></script>
      </section>
    </section>
    <section>
      <header>
        <h4>Public API</h4>
      </header>
      <section>If we define public API, all methods and parameters should have explicite type.</section>
    </section>
    <section>
      <header>
        <h4>Operators</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/ccfc2bdb0bb0a90dec56.js"></script>
        <div>To be consisten:</div>
        <ul>
          <li>all operators like <code>+, !, -</code>, etc should be used with infix notation,</li>
          <li>in other cases we <b>should</b> use dot notation.</li>
        </ul>
      </section>
    </section>
    <section>
      <header>
        <h4>Named parameters</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/fe5d0b8fa16a6857a2eb.js"></script>
        <div>When we have a lot of parameters (especially with the same type - integers and strings), we should used named parameters. It makes code more readable and more expressible.</div>
      </section>
    </section>
    <section>
      <header>
        <h4>Imports in code's block are ok</h4>
      </header>
      <section>If you need specific import only in one function, import it in function body.</section>
    </section>
    <section>
      <header>
        <h4>Private access modifiers in Scala</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/4965cc09b3b50c3c30a4.js"></script><code>private [this]</code> is very restrict. It can be be called only in "this". You can use package access modifier (it could be good for tests).
      </section>
    </section>
    <section>
      <header>
        <h4>Should I extend <code>App</code> or should I use <code>main(args: Array[String])</code>?</h4>
      </header>
      <section>Extending <code>App</code> is code for prototyping. In production you should use <code>main</code>. Why?
        <ul>
          <li>Whole object body is treatead as main,</li>
          <li>you don't hava access to <code>args</code>,</li>
          <li>
            <blockquote cite="http://www.scala-lang.org/api/current/index.html#scala.App" class="small">It should be noted that this trait is implemented using the DelayedInit functionality, which means that fields of the object will not have been initialized before the main method has been executed.</blockquote>
          </li>
        </ul>
      </section>
    </section>
    <section>
      <header>
        <h4><code>copy</code> method in case classes</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/0042b1d075075a483a5b.js"></script>
      </section>
    </section>
    <section>
      <header>
        <h4><code>List</code> vs <code>Vector</code></h4>
      </header>
      <section> 
        <h5><code>List</code></h5>
        <div>List has only pointer to first element - it adds very fast to head of list. To add element to end of list it has to iterate throught all elements (<code>O(n)</code>).</div>
        <h5><code>Vector</code></h5>
        <div>All operations are constant in time (even putting element in the middile of collection).</div>
        <h5>Performance characteristics</h5>
        <div>
          <div><img src="img/performance.png" alt="Performance characteristics"/></div><a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html">Performance characteristics</a>
        </div>
      </section>
    </section>
    <section>
      <header>
        <h4><code>Seq</code> is mutable!</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/c8c78a917e8a794cfdf9.js"></script>
        <div>There is at least one mutable subtype of <code>Seq</code>: <code>WrappedArray</code>. To be sure sequence is immutable use <code>scala.collection.immutable.Seq</code>.</div>
      </section>
    </section>
    <section>
      <header>
        <h4>Future</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/21b648b8a1fae1da8123.js"></script>
        <div><code>Await.result</code> is blocking operation.</div>
      </section>
    </section>
    <section>
      <header>
        <h4>Diffrence between <code>=</code> and <code>&lt;-</code> in for comprehension</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/77cd21d39a09355c24f2.js"></script>
        <div><code>&lt;-</code> will "unpack", <code>=</code> is simple assigment.</div>
      </section>
    </section>
    <section>
      <header>
        <h4><code>Try</code> object/trait</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/e9446d855e33a5b6ce7c.js"></script>
        <div>In <a href="http://www.scalactic.org/">scalactic</a> you can use <code>String Or ErrorMessage</code> (<code>Good(...)</code>, <code>Bad(...)</code> subclasses).</div>
      </section>
    </section>
    <section>
      <header>
        <h4><code>if</code> in for-comprehension</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/e5e68fd31c78bf766506.js"></script>
        <div>You can use <code>if</code> in for-comprehension.</div>
        <div>Every for-comprehension can be replaced with <code>flatMap</code> and <code>map</code> (outer iteration is <code>flatMap</code>).</div>
      </section>
    </section>
    <section>
      <header>
        <h4><code>filter</code> vs <code>withFilter</code></h4>
      </header>
      <section>
        <div><code>filter</code> always returns collections. <code>withFilter</code> returns generator. You can "join" join many generators.</div>
        <div>You should <code>withFilter</code> when you have many filters.</div>
      </section>
    </section>
    <section>
      <header>
        <h4>Class modifiers</h4>
      </header>
      <section>
        <ul>
          <li><code>final class Animal</code> you cannnot extend Animal</li>
          <li><code>sealed</code> All subtypes must be defined in this file. <code>sealed</code> should be define when you use <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">ADT (algebraic data types)</a>. <code>sealed</code> is very helpfull in pattern matching.</li>
        </ul>
      </section>
    </section>
    <section>
      <header>
        <h4>Traits linearization</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/8c329a089e5b1bcdd51a.js"></script>
      </section>
    </section>
    <section>
      <header>
        <h4>Const Pattern Mattching</h4>
      </header>
      <section>
        <script src="https://gist.github.com/michalkowol/e334f8bafff000e11549.js"></script>
      </section>
    </section>
    <section>
      <header>
        <h4>Others</h4>
      </header>
      <section>
        <ul>
          <li>In subclass you can replace <code>def</code> with <code>val</code>.</li>
          <li>There is type <code>Either</code> and <code>Options</code> - very usefull to handle errors or null pointers.</li>
          <li><code>lazy val</code> can caused some problems. Instead of <code>lazy val</code> maybe yhou should use <code>def</code>.</li>
          <li><code>s"..."</code> - string interpolation, <code>f"..."</code> - formating (<code>f"$value%02x"</code> (300 -&gt; 12c)).</li>
          <li><code>trait</code> or <code>abstract class</code>? In most cases <code>trait</code> is better. The only reason to use <code>abstract class</code> is when we have to use constructor params.</li>
          <li>If we ovverride method, it should call <code>super</code>.</li>
          <li>It is better to use simple <code>case classes</code> than <code>Tuple</code>.</li>
        </ul>
      </section>
    </section>
  </div>
</div>